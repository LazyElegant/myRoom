<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <style type="text/css">
        * {
            padding: 0;
            margin: 0;
        }
        body {
            background: url(img/bg.jpg) left top repeat;
            width: 1080px;
            height: 1000px;
            margin-left: 5px;
            margin-top:55px;
        }

        #btn_group {
            position: absolute;
            left:1050px;
            margin-top: -700px;
        }
		
		.time{
			float: left;
			margin: 30px 0 0 150px; 
			width: 250px;
			height: 50px;
			font-size: 30px;
			text-align: center;
			line-height: 50px;
		}
		.blackChess{
			border: black 3px solid;
		}
		.whiteChess{
			border: white 3px solid;
		}


    </style>
    <script src="js/jquery-3.2.1.min.js"></script>
    <script type="text/javascript">
        var totalData = [];
        var counts = 0;
        var canvas;
        var context;
        var isWhite = true;//设置是否该轮到白棋
        var isWell = false;//设置该局棋盘是否赢了，如果赢了就不能再走了
        var img_b = new Image();
        img_b.src = "img/b.png";//黑棋图片
        var img_w = new Image();
        img_w.src = "img/w.png";//白棋图片
        var img_b2 = new Image();
        img_b2.src = "img/b-lz.png";//红♥黑棋图片
        var img_w2 = new Image();
        img_w2.src = "img/w-lz.png";//红♥白棋图片
		
		var whiteTime = 0; //白棋所用时间
		var blackTime = 0; //黑棋所用时间
		var clock;
        
		var chessData = new Array(225).fill(0);//这个为棋盘的一维数组用来保存棋盘信息，初始化0为没有走过的，1为白棋走的，2为黑棋走的


        function drawRect() {//页面加载完毕调用函数，初始化棋盘
            canvas = document.getElementById("canvas");
            context = canvas.getContext("2d");

            // for (var i = 0; i <= 640; i += 40) {//绘制棋盘的线
            //     context.beginPath();
            //     context.moveTo(0, i);
            //     context.lineTo(640, i);
            //     context.closePath();
            //     context.stroke();

            //     context.beginPath();
            //     context.moveTo(i, 0);
            //     context.lineTo(i, 640);
            //     context.closePath();
            //     context.stroke();
            // }
            // for (var i = 0; i < 900; i += 60) {//绘制棋盘的线
            //     context.beginPath();
            //     context.moveTo(60, i + 60);
            //     context.lineTo(900, i + 60);
            //     context.closePath();
            //     context.stroke();
            //     context.strokeStyle = '#003333';
            //     context.lineWidth = '0.5';

            //     context.beginPath();
            //     context.moveTo(i + 60, 60);
            //     context.lineTo(i + 60, 900);
            //     context.closePath();
            //     context.stroke();
            //     context.strokeStyle = '#003333';
            //     context.lineWidth = '0.5';
            // }

            //螺旋数字矩阵算法实现棋盘上数字排列
            var chess = sprialArray(7);

            //线条颜色
            context.strokeStyle = '#000333';
             context.lineWidth = '0.5';

            for (var i = 1; i <= 15; i++) {
                for (var j = 1; j <= 15; j++) {

                    context.beginPath();
                    //18这个参数代表圆的半径 依次为横坐标 纵坐标 圆的半径 后面0-2Π别动
                    context.arc((j - 1) * 60 + 60, (i - 1) * 60 + 60, 28, 0, 2 * Math.PI);
                    context.fillStyle = "#DEB887";//设置圆圈填充颜色
                    context.fill();//开始填充
                    context.stroke();
                }
            }

            //数字字体及颜色大小调整
            context.font = "bold 27px Arial";
            context.fillStyle = "#000000";

            for (var i = 1; i <= 15; i++) {
                for (var j = 1; j <= 15; j++) {
                    var num = chess[i - 1][j - 1];
                    var len = num.toString().length;
                    var numStr = "";
                    if (len == 1) {
                        numStr += "  " + num;
                    } else if (len == 2) {
                        numStr += " " + num;
                    } else {
                        numStr = num;
                    }
                    context.fillText(numStr, (j - 1) * 60 + 37, (i - 1) * 60 + 69);
                }
            }
        }
        function play(e) {//鼠标点击时发生
            var _top = document.getElementById("canvas").offsetTop,
                _left = document.getElementById("canvas").offsetLeft;
            var x = parseInt((e.clientX - 20 - _left) / 60);//计算鼠标点击的区域，如果点击了（65，65），那么就是点击了（1，1）的位置
            var y = parseInt((e.clientY - 20 - _top) / 60);

            //判断是否悔棋后再下的子，如果是则恢复当前counts对应的chessData
            if (counts < totalData.length && counts) {
                // var _chessData = totalData[counts-1].chessClone;
                // for (var k = 0; k < chessData.length; k++) {
                //     chessData[k] = _chessData[k];
                // }
                totalData.splice(counts, totalData.length - counts);
            }
            //判断该位置是否被下过了
            if (chessData[x + 15 * y] != 0) {
                return;
            }
            counts += 1;
            // 克隆 chessData,避免数组更新后totalData内所有的chessData都更新
            var chessClone = new Array(225);
            for (var k = 0; k < chessData.length; k++) {
                chessClone[k] = chessData[k];
            }
            if (isWhite) {
                isWhite = false;
                totalData.push({ chess: 1, x, y });
                drawChess(1, x, y);
            }
            else {
                isWhite = true;
                totalData.push({ chess: 2, x, y });
                drawChess(2, x, y);
            }
			if(!isWell){
				window.clearInterval(clock);
				clock =self.setInterval("tick()",1000);
			}
            $("#sound").html("").append("<audio autoplay='autoplay' src='./bai.wav'></audio>");
        }
        function drawChess(chess, x, y) {//参数为，棋（1为白棋，2为黑棋），数组位置
            if (isWell == true) {
                alert("已经结束了，如果需要重新玩，请刷新");
                return;
            }
            if (x >= 0 && x < 15 && y >= 0 && y < 15) {
                if (chess == 1) {
                    context.drawImage(img_w, x * 60 + 27, y * 60 + 27);//绘制白棋
                    chessData[x + 15 * y] = 1;
                }
                else {
                    context.drawImage(img_b, x * 60 + 27, y * 60 + 27);
                    chessData[x + 15 * y] = 2;
                }
                judge(x, y, chess);
            }
        }
        function judge(x, y, chess) {//判断该局棋盘是否赢了
            var count1 = 0;
            var count2 = 0;
            var count3 = 0;
            var count4 = 0;
            //左右判断
            for (var i = x; i >= 0; i--) {
                if (chessData[i + 15 * y] != chess) {
                    break;
                }
                count1++;
            }
            for (var i = x + 1; i < 15; i++) {
                if (chessData[i + 15 * y] != chess) {
                    break;
                }
                count1++;
            }
            //上下判断
            for (var i = y; i >= 0; i--) {
                if (chessData[x + 15 * i] != chess) {
                    break;
                }
                count2++;
            }
            for (var i = y + 1; i < 15; i++) {
                if (chessData[x + 15 * i] != chess) {
                    break;
                }
                count2++;
            }
            //左上右下判断
            for (var i = x, j = y; i >= 0 && j >= 0; i--, j--) {
                if (chessData[i + 15 * j] != chess) {
                    break;
                }
                count3++;
            }
            for (var i = x + 1, j = y + 1; i < 15 && j < 15; i++, j++) {
                if (chessData[i + 15 * j] != chess) {
                    break;
                }
                count3++;
            }
            //右上左下判断
            for (var i = x, j = y; i >= 0 && j < 15; i--, j++) {
                if (chessData[i + 15 * j] != chess) {
                    break;
                }
                count4++;
            }
            for (var i = x + 1, j = y - 1; i < 15 && j >= 0; i++, j--) {
                if (chessData[i + 15 * j] != chess) {
                    break;
                }
                count4++;
            }
            if (count1 >= 5 || count2 >= 5 || count3 >= 5 || count4 >= 5) {
                if (chess == 1) {
                    alert("黑棋赢了");
                }
                else {
                    alert("白棋赢了");
                }
				window.clearInterval(clock)
                isWell = true;//设置该局棋盘已经赢了，不可以再走了
            }
			
        }
        function backGame() {
            if (counts < 2) return;
            chessData = new Array(225).fill(0);
            counts -= 1;
            isWell = false;
            context.clearRect(0, 0, 900, 900);
            drawRect();
            isWhite = !isWhite;			
			window.clearInterval(clock);
			clock =self.setInterval("tick()",1000);
            for (var i = 0; i < counts; i++) {
                (function (arg) {
                    drawChess(totalData[arg].chess, totalData[arg].x, totalData[arg].y);
                })(i);
            }
        }
        function regainGame() {
            if (counts > totalData.length - 1) return;
            counts += 1;
			window.clearInterval(clock);
			clock =self.setInterval("tick()",1000);
            isWhite = !isWhite;
            for (var i = 0; i < counts; i++) {
                (function (arg) {
                    drawChess(totalData[arg].chess, totalData[arg].x, totalData[arg].y);
                })(i);
            }
        }
        var storage = window.localStorage;
        function beginGame() {
            // var leizhu_num = $("#leizhu_num").val();
            // var leizhu_name = $("#leizhu_name").val();
            // var phb_textarea=$("#phb_textarea").val();
            // storage.setItem("leizhu_num", leizhu_num);
            // storage.setItem("leizhu_name", leizhu_name);
            // storage.setItem("phb_textarea", phb_textarea);
            // history.go(0);
			whiteTime = 0
			blackTime = 0
			window.clearInterval(clock);
			clock =self.setInterval("tick()",1000);
            window.location.reload();
        }

        //螺旋数字矩阵算法
        function sprialArray(num) {
            var n = 2 * num + 1;
            var m = 0;
            var a = n * n;
            var arr = [];
            for (var i = 0; i < n; i++) {
                arr[i] = new Array();
                for (var j = 0; j < n; j++) {
                    arr[i][j] = 1;//当n为偶数时，下面的循环无法给中间的项赋值所以初始为n*n
                }
            }
            while (m < n / 2 + 1) {
                //向左
                for (var z = m; z < n - m - 1; z++) {
                    arr[m][n - 1 - z] = a--;
                }
                //向下
                for (var d = m; d < n - m - 1; d++) {
                    arr[d][m] = a--;
                }
                //向右
                for (var r = m; r < n - m - 1; r++) {
                    arr[n - m - 1][r] = a--;
                }
                //向上
                for (var u = m; u < n - m - 1; u++) {
                    arr[n - u - 1][n - m - 1] = a--;
                }
                m = m + 1;//m=0时为最外圈赋值，每循环一次进行缩圈，则m+1
            }
            return arr;
        }
		
		function tick(time){
			if(!isWhite){
				$('#whiteChess_time').text(aa(this.whiteTime))
				this.whiteTime = whiteTime+1
			}else{
				$('#blackChess_time').text(aa(this.blackTime))
				blackTime = blackTime+1
			}
		}
		function aa(time){
			var hour = 0, minute = 0, second = 0;
			time = time + 1;
			console.log(time);
			hour = Math.floor(time / 3600) >= 10 ? Math.floor(time / 3600) : '0' + Math.floor(time / 3600);
			time -= 3600 * hour;
			minute = Math.floor(time / 60) >= 10 ? Math.floor(time / 60) : '0' + Math.floor(time / 60);
			time -= 60 * minute;
			second = time >= 10 ? time : '0' + time;
			return hour + ":" + minute + ":" + second
		}
    </script>
</head>

<body onload="drawRect()">

        <!-- <div class="tip">
            <span id="leizhu"
                style="font-weight: bold;font-size: 50px;font-family: Arial, Helvetica, sans-serif;"><input
                    type="text" id="leizhu_name" class="myInput1" />&nbsp;&nbsp;<input type="text" id="leizhu_num"
                    class="myInput2" /></span>
        </div> -->
        <!-- <div class="sider">
            <b onmousedown="backGame()">悔棋</b><br /><br /><br /><b onmousedown="regainGame()">恢复</b><br /><br /><br /><b
                onmousedown="beginGame()">重开</b>
        </div> -->

        <canvas width="960" id="canvas" onmousedown="play(event)" height="960"
            style="margin: 0 auto;border-radius:15px; display: block;background: url(img/wood2.jpg)">你的浏览器不支持HTML5
            canvas ，请使用 google
            chrome 浏览器 打开.
        </canvas>

        <!-- <div id="paihangbang"><textarea id="phb_textarea"></textarea></div> -->
        <div id="btn_group">
            <div class="btn_div" onmousedown="backGame()"><span class="btn"><img src="img\hq.png" ></span></div><br/>
            <div class="btn_div" onmousedown="regainGame()"><span class="btn"><img src="img\cx.png" ></span></div><br/>
            <div class="btn_div" onmousedown="beginGame()"><span class="btn"><img src="img\ck.png" ></span></div>
        </div>
        
		<div id="time_group">
			<div id="whiteChess_time" class="time whiteChess">00:00:00</div>
			<div id="blackChess_time" class="time blackChess">00:00:00</div>
		</div>
    </div>
    <bgsound id="sound" src="" loop=1 style="display: none;"></bgsound>
    
	
</body>
<!-- <script>
    $("#leizhu_name").val(storage["leizhu_name"]);
    $("#leizhu_num").val(storage["leizhu_num"]);
    $("#phb_textarea").val(storage["phb_textarea"]);
</script> -->

</html>